py-4: Elemanın üst ve alt kısmına 1rem (16px) kadar dikey boşluk (padding) ekler.
flex: Elemanı flex düzenine sokar, yani esnek kutu modelini aktif eder.
items-center: Flex konteynerinin çocuklarını (elemanlarını) çapraz eksende (satır için dikey, sütun için yatay) merkeze hizalar.
flex-col: Flex düzeninin yönünü sütun (dikey) olarak değiştirir.
justify-center: Elemanları ana eksende (bu durumda dikey olarak) merkeze hizalar.
gap-2: Flex elemanları arasına 0.5rem (8px) boşluk ekler.
px-4: Elemanın sol ve sağ tarafına 1rem (16px) kadar yatay boşluk (padding) ekler.
text-[#211E1F]: Yazı rengini özel bir hexadecimal renk değeri olan #211E1F (çok koyu gri) olarak ayarlar.
max-w-[1280px]: Elemanın maksimum genişliğini 1280px olarak ayarlar.
justify-center: Flex konteynerindeki elemanları ana eksende (bu durumda yatayda) merkeze hizalar.
gap-2: Flex elemanları arasına 0.5rem (8px) boşluk ekler.
px-4: Elemanın sol ve sağ tarafına 1rem (16px) yatay boşluk (padding) ekle
type="text": Bu, input alanının tipinin metin olduğunu belirtir.
[(ngModel)]="currentValue": Angular’ın two-way data binding özelliğini kullanarak, bu input alanındaki değeri currentValue değişkeniyle bağlar. Kullanıcı input'a bir değer girdiğinde, currentValue değişir ve tersi de geçerlidir.
mwlFlatpickr: Bu, Flatpickr kütüphanesini entegre eden bir Angular direktifidir. Bu direktif, input alanına bir tarih seçici işlevi ekler.
[locale]="locale": locale (yerelleştirme) ayarlarını input elemanına bağlar. Tarih formatı, dil, vb. yerelleştirilmiş özellikler burada belirlenir.
dateFormat="d.m.Y": Tarih formatını gün.ay.yıl (örneğin, 06.01.2025) şeklinde ayarlar.
[disableMobile]="true": Bu özellik, mobil cihazlarda tarih seçici popup'ını devre dışı bırakır. Mobil tarayıcıda, tarih seçiciyi açmaz.
(change)="reset()": Kullanıcı input alanında bir değişiklik yaptığında, reset() fonksiyonunu tetikler. Bu genellikle, input değerini sıfırlamak veya başka bir işlem yapmak için kullanılır.
[allowInput]="true": Kullanıcının tarihi elle girmesine izin verir. Bu özellik etkinse, kullanıcı tarih değerini manuel olarak da yazabilir.
[minDate]="minDate": Minimum tarih değerini ayarlar. minDate burada bir değişken olup, seçilebilecek en erken tarihi belirler.
[maxDate]="maxDate": Maksimum tarih değerini ayarlar. maxDate burada bir değişken olup, seçilebilecek en geç tarihi belirler.
[convertModelValue]="true": Modeldeki değerin doğru biçime dönüştürülmesini sağlar. Bu, tarih formatlama ve dönüştürme işlevi için kullanılır.
[ngModelOptions]="{ standalone: true }": Bu, ngModel'in standalone (bağımsız) olarak kullanılmasını sağlar, yani form elemanının dışında bağımsız bir şekilde çalışmasına izin verir.
class="border-transparent focus:border-transparent focus:!ring-0 focus:outline-none w-full text-[#6E6E6E] h-[50px] bg-transparent":
border-transparent: Border'ı şeffaf yapar.
focus:border-transparent: Input odaklandığında border'ı şeffaf yapar.
focus:!ring-0: Odaklandığında herhangi bir "ring" (çevre çizgisi) eklenmesini engeller.
focus:outline-none: Odaklandığında outline'ı kaldırır.
w-full: Input alanının genişliğini %100 yapar.
text-[#6E6E6E]: Yazı rengini #6E6E6E (gri) yapar.
h-[50px]: Input alanının yüksekliğini 50px yapar.
bg-transparent: Arka plan rengini şeffaf yapar.
[placeholder]="section.placeholder": Placeholder (yer tutucu) metnini section.placeholder değerine bağlar. Bu, input alanında herhangi bir değer girilmeden önce görünecek olan metni belirtir.

Bu <path> elementi, SVG (Scalable Vector Graphics) formatında bir çizim komutudur ve genellikle bir şekil veya simge çizmek için kullanılır. Her bir özelliğin anlamını aşağıda açıklıyorum:

d Özelliği:
<path> elementinin en önemli özelliğidir ve çizilecek yolu (yani şekli) belirtir. Bu değer, bir dizi komut ve koordinattan oluşur. Burada, yol komutları şunlardır:

M: "Move To" komutu, bir başlangıç noktasına taşır (bu örnekte M6.71277 6.7226 ile başlar).
C: "Cubic Bezier Curve" komutu, 3 nokta kullanarak bir bezier eğrisi çizer (örneğin, C3.66479 8.79527 2 12 2 12).
L: "Line To" komutu, bir çizgi çizer.
Z: Yolun kapanması için kullanılan komut (yolun başlangıcına geri dönmek için).
Bu komutlar, şeklin her bir segmentini tanımlar.

stroke Özelliği:
stroke="currentColor": Bu özellik, çizimin rengini ayarlamak için kullanılır. Burada currentColor kullanılmış, bu da stroke renginin, elemanın mevcut metin rengini alacağı anlamına gelir. Eğer SVG'nin içine yerleştirildiği HTML öğesinde bir renk belirlenmişse, bu renk çizimde kullanılacaktır.

stroke-width Özelliği:
stroke-width="2": Çizginin kalınlığını belirler. Burada değer 2 olarak ayarlanmış, yani çizgi kalınlığı 2 birim olacak.

stroke-linecap Özelliği:
stroke-linecap="round": Çizginin uçlarının nasıl görüneceğini belirler. round değeri, çizginin uçlarının yuvarlatılmış olacağı anlamına gelir.

stroke-linejoin Özelliği:
stroke-linejoin="round": Çizgilerin birleşim noktalarının nasıl görüneceğini belirler. round değeri, çizgilerin birleşim noktalarını yuvarlatır.
<ng-select> Elementi:
class="w-[200px]": Bu özellik, seçim kutusunun genişliğini 200 piksel olarak ayarlar. Bu, CSS sınıfıdır ve burada Tailwind CSS kullanılarak genişlik belirlenmiştir.
[clearable]="false": Bu, seçim kutusunun kullanıcı tarafından temizlenmesini engeller. Yani, kullanıcı bir seçim yaptıktan sonra kutunun içeriğini sıfırlamak mümkün olmaz.
[searchable]="true": Bu, seçim kutusunun arama yapılabilir olmasını sağlar. Kullanıcılar, seçenekler arasında arama yaparak daha hızlı seçim yapabilir.
[(ngModel)]="countryGuid": Two-way data binding özelliğiyle, seçim kutusundaki değeri Angular bileşenindeki countryGuid değişkenine bağlar. Kullanıcı bir seçenek seçtiğinde, countryGuid değişir; tersi de geçerlidir.
(change)="updateCountryCode($event)": Bu, seçim kutusunda bir değişiklik yapıldığında (yani bir ülke seçildiğinde), updateCountryCode($event) fonksiyonunun tetiklenmesini sağlar. Bu fonksiyon, seçilen ülkenin kodunu almak veya güncellemek için kullanılır.
[ngModelOptions]="{ standalone: true }": Bu, ngModel'in standalone (bağımsız) olarak kullanılmasını sağlar. Bu, bileşenin bir form elemanı gibi davranmamasını ve bağımsız olarak veri bağlama işlemi yapmasını sağlar.
[placeholder]="getInput('phoneCodePlaceholder')": Bu özellik, seçim kutusunun içinde görünen yer tutucu (placeholder) metnini belirler. getInput('phoneCodePlaceholder') fonksiyonu, muhtemelen bir çeviri veya dinamik değer döndürür ve yer tutucu olarak kullanılır.
2. <ng-option> Elementi:
*ngFor="let c of translatedCountries": Bu Angular yapısı, translatedCountries dizisindeki her bir öğe için bir <ng-option> elementi oluşturur. Yani, her ülke için bir seçenek gösterilir.
[value]="c.guid": Bu, her bir seçenek için değer olarak c.guid'yi (muhtemelen ülkenin benzersiz kimliği) atar. Bu değer, seçim yapıldığında countryGuid'ye atanır.
{{ c.name }} {{ c.phoneCode }}: Bu, her seçeneğin içinde görünen metni belirler. Seçenek, ülke adını (c.name) ve telefon kodunu (c.phoneCode) gösterir. Örneğin, "Türkiye +90" gibi bir seçenek.
constructor(@Inject(PLATFORM_ID) private _platformId: Object) {}:
constructor: Angular bileşenleri veya servisleri oluşturulurken çağrılan yapıcı fonksiyondur. Burada, sınıfın bir örneği oluşturulurken bazı bağımlılıklar inject edilmektedir.

@Inject(PLATFORM_ID): Angular'da, bağımlılıkları doğrudan enjeksiyon yerine belirli bir token ile inject etmek için @Inject() dekoratörü kullanılır. Burada PLATFORM_ID Angular'ın özel bir token'ıdır ve bu token, çalıştırılan ortamı (platformu) temsil eder. Yani, Angular'ın uygulamanın hangi platformda çalıştığını bilmesini sağlar.

PLATFORM_ID bir token'dır ve bu, hangi platformda çalışıldığını belirtir. Bu genellikle:
Platform Browser: Tarayıcıda çalışıyorsa,
Platform Server: Sunucuda çalışıyorsa,
Platform Universal: Angular Universal (sunucu tarafı render) kullanıyorsa, vs.
private _platformId: Object: Bu, _platformId isminde, Object türünde bir değişken tanımlar. Bu değişken, PLATFORM_ID'den inject edilen değeri tutar. private anahtar kelimesi, bu değişkenin sadece sınıf içinde erişilebilir olduğu anlamına gelir.

Özet:
Bu constructor, PLATFORM_ID sembolünü kullanarak Angular'ın çalıştığı platform hakkında bilgi alır.
_platformId değişkeni, uygulamanın hangi platformda çalıştığını belirtir ve genellikle platforma özgü işlemler yapmak için kullanılır (örneğin, sunucu tarafı rendering veya belirli platform özelliklerine göre farklı davranışlar sergilemek için).
Bu tür bir kullanım, platforma özel mantık yazılmasına olanak tanır ve özellikle Angular Universal gibi senaryolarda sunucu ve tarayıcı için farklı davranışlar sergilemek için faydalıdır.
[clearable]="false": Bu özellik, seçim kutusunun "temizlenebilir" olup olmadığını belirler. Burada false olarak ayarlandığı için, kullanıcı seçim yaptıktan sonra kutudaki değeri temizleyemez. Yani, bir değer seçildikten sonra, bu değeri boşaltmak mümkün olmaz.

[searchable]="true": Bu özellik, seçim kutusunun içinde arama yapılabilir olmasını sağlar. Kullanıcılar, uzun bir seçenek listesinde arama yaparak daha hızlı seçim yapabilir.

[(ngModel)]="value": Bu, Angular'ın two-way data binding (çift yönlü veri bağlama) özelliğidir. Kullanıcı seçim yaptığında, seçilen değer value değişkenine atanır ve value değişkeninde yapılan değişiklikler de seçim kutusunda görünecektir. Yani, bu özellik seçim kutusunun veri ile bağlanmasını sağlar.

[ngModelOptions]="{ standalone: true }": Bu özellik, ngModel'in standalone (bağımsız) olarak kullanılmasını sağlar. Bu, ngModel'in, Angular form yapıları dışında bağımsız bir şekilde çalışmasını ve veri bağlama işlevini yerine getirmesini sağlar.
type="text":

Bu, input alanının türünü belirtir. Burada text türü kullanıldığından, kullanıcı metin girebilir.
[(ngModel)]="value":

Bu, Angular’ın two-way data binding (iki yönlü veri bağlama) özelliğini kullanır. Yani, input alanındaki değer ile value değişkeni arasında otomatik olarak bir bağlantı kurulmuştur.
Kullanıcı input'a bir değer girdiğinde, value değişkeni otomatik olarak güncellenir ve tersi de geçerlidir.
(input)="reset($event)":

(input) event'ı, kullanıcı input alanına her yazı yazdığında tetiklenir. Burada, reset($event) fonksiyonu çağrılır.
Bu fonksiyon, genellikle kullanıcı yazarken yapılan işlemi (örneğin, değeri sıfırlamak veya başka bir işlem yapmak) kontrol etmek için kullanılır. $event değişkeni, input event’inin detaylarını taşır.
[disabled]="disabled":

Bu özellik, input alanının devre dışı olup olmadığını belirler. disabled değişkeni, dışarıdan bir değer alır ve input alanı bu değere göre etkin veya devre dışı olur.
Eğer disabled true olarak ayarlanmışsa, input alanı devre dışı olur ve kullanıcı metin giremez.
[ngModelOptions]="{ standalone: true }":

Bu, ngModel'in standalone (bağımsız) olarak kullanılmasını sağlar.
Yani, bu input alanı Angular form yapısının dışında bağımsız olarak çalışır. Bu, form denetimleri (form controls) dışında kullanıldığında faydalıdır.
class="border-transparent focus:border-transparent focus:!ring-0 focus:outline-none w-full text-[#6E6E6E] h-[42px] bg-transparent":

border-transparent: Input kutusunun kenarlığını şeffaf yapar.
focus:border-transparent: Input odaklandığında (kullanıcı kutuya tıkladığında veya yazmaya başladığında) kenarlığını şeffaf yapar.
focus:!ring-0: Odaklandığında (focus) herhangi bir "ring" (çevre çizgisi) eklenmesini engeller.
focus:outline-none: Odaklanıldığında input'un etrafındaki outline'ı (çerçeve) kaldırır.
w-full: Input alanının genişliğini %100 yapar, yani genişliği içinde bulunduğu alanın tamamını kaplar.
text-[#6E6E6E]: Input içindeki metnin rengini #6E6E6E (gri) yapar.
h-[42px]: Input alanının yüksekliğini 42 piksel yapar.
bg-transparent: Input alanının arka planını şeffaf yapar.
[placeholder]="section?.placeholder":

Bu, input alanına bir yer tutucu (placeholder) metni ekler. section?.placeholder ifadesi, section nesnesinden placeholder özelliğini alır.
? operatörü, optional chaining (isteğe bağlı zincirleme) kullanılarak section nesnesinin var olup olmadığını kontrol eder. Eğer section nesnesi yoksa, herhangi bir hata oluşmaz ve placeholder boş kalır.
İşte Angular yaşam döngüsündeki ana aşamalar ve ilgili yaşam döngüsü kancaları:

ngOnChanges:

Bir bileşenin veya direktifin input özellikleri değiştiğinde çağrılır.
ngOnInit:

Bileşen veya direktif başlatıldığında, yani ilk kez DOM'a yerleştirildiğinde çağrılır.
ngDoCheck:

Angular'ın değişiklik algılama mekanizması dışında özel kontroller yapmak için kullanılır.
ngAfterContentInit:

Bileşenin içerik (content) ve çocuk bileşenleri DOM'a eklendikten sonra çağrılır.
ngAfterContentChecked:

İçerik değiştikçe her kontrol sonrası çağrılır.
ngAfterViewInit:

Bileşenin görsel görünümü ve çocuk bileşenleri DOM'a yerleştirildikten sonra çağrılır.
ngAfterViewChecked:

Görünüm değiştikçe her kontrol sonrası çağrılır.
ngOnDestroy:

Bileşen veya direktif yok edilmeden önce çağrılır. Bu, bileşen veya direktif DOM'dan kaldırıldığında son bir temizlik işlemi yapmanızı sağlar.
u, bir SVG (Scalable Vector Graphics) öğesinin <path> elemanıdır. <path>, SVG çizimlerinde, çeşitli şekillerin tanımlanmasına ve çizilmesine yarayan bir etiket olup, genellikle karmaşık şekillerin oluşturulmasında kullanılır. Bu örnekteki <path> elemanı, belirli bir çizimi ifade eder.

Özniteliklerin Açıklamaları:
d="M27.3281 16.7617H28.6465V19.4009H27.3281V16.7617Z":

Bu, path komutlarını içerir ve şeklin çizilmesini tanımlar. Burada, d (data) özniteliği, şeklin geometrisini ve hareketlerini belirtir.

M27.3281 16.7617: Bu komut, çizimin başlangıç noktasını belirler. M, "move to" (git) komutudur ve belirtilen koordinatlara, yani x=27.3281 ve y=16.7617'ye hareket eder.

H28.6465: H komutu, yatay doğrultuda hareketi belirtir. Burada x koordinatını 28.6465'e getirir, yani yatayda bir çizgi çizer.

V19.4009: V komutu, dikey doğrultuda hareketi belirtir. Burada y koordinatını 19.4009'a getirir, yani dikey bir çizgi çizer.

H27.3281: Yine bir yatay hareket komutudur. Bu sefer x koordinatını 27.3281'e getirir, yani sağdan sola doğru yatay bir çizgi çizer.

V16.7617: Bu dikey hareket komutudur ve y koordinatını tekrar başlangıç noktası olan 16.7617'ye getirir, yani çizgiyi aşağıya doğru çizer.

Z: Z komutu, çizimi kapatır, yani en son nokta ile ilk noktayı birleştirir ve şekli tamamlar.

Bu komutlar sonucunda, belirli bir dikdörtgen şekli çizilmektedir. Başlangıç noktasından sağa, aşağıya, sola ve yukarıya doğru hareket edilerek, kapalı bir şekil elde edilir.

fill="#E2B101":

Bu öznitelik, path şeklinin içinin hangi renkle doldurulacağını belirtir. #E2B101 hexadecimal renk kodu, sarımsı bir altın rengini ifade eder. Yani, çizilen şekil bu renk ile doldurulacaktır.
<rect x="4" y="4" width="48" height="48" rx="24" fill="#FEF0C7" />
x="4":

Dikdörtgenin sol üst köşesinin yatay koordinatını belirtir. Bu durumda, dikdörtgen 4 birim sağa yerleştirilmiştir.
y="4":

Dikdörtgenin sol üst köşesinin dikey koordinatını belirtir. Bu durumda, dikdörtgen 4 birim aşağıya yerleştirilmiştir.
width="48":

Dikdörtgenin genişliğini belirtir. Bu dikdörtgenin genişliği 48 birimdir.
height="48":

Dikdörtgenin yüksekliğini belirtir. Bu dikdörtgenin yüksekliği 48 birimdir.
rx="24":

Dikdörtgenin köşe yarıçapını belirtir. rx="24" değeri, köşelerin yuvarlatılacağına ve her köşe için 24 birimlik bir yarıçap kullanılacağına işaret eder. Bu, dikdörtgenin köşelerini yuvarlatan bir efekt oluşturur.
fill="#FEF0C7":

Dikdörtgenin iç rengini belirtir. #FEF0C7 hexadecimal renk kodu, çok açık bir sarı rengini ifade eder. Bu, dikdörtgenin iç kısmını bu renk ile doldurur.

svg
  width="80"
  height="80"
  viewBox="0 0 56 56"
  class="pt-4"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
width="80":

SVG öğesinin genişliğini belirtir. Burada, SVG öğesinin genişliği 80 birim (piksel) olarak ayarlanmıştır. Yani, görüntü 80 piksel genişliğinde olacaktır.
height="80":

SVG öğesinin yüksekliğini belirtir. Burada, SVG öğesinin yüksekliği 80 birim (piksel) olarak ayarlanmıştır. Bu, görüntü 80 piksel yüksekliğinde olacaktır.
viewBox="0 0 56 56":

viewBox, SVG öğesinin görsel alanını tanımlar. 0 0 başlangıç koordinatlarını (x, y) belirtir. Burada, koordinatlar (0, 0) konumunda başlar.
56 56, SVG'nin çizim alanının genişliğini ve yüksekliğini belirtir. Yani, 56x56 birimlik bir koordinat sistemi kullanılır ve bu sistemdeki çizimler SVG'ye uygun şekilde yerleştirilir.
class="pt-4":

Bu, SVG öğesinin dış stilini (CSS sınıfını) belirtir. pt-4, büyük olasılıkla CSS ile tanımlanmış bir sınıf olup, SVG öğesine 4 birimlik bir üst (padding-top) boşluk ekler. Bu, öğenin üst kısmında ekstra boşluk bırakmak için kullanılır. Ancak bu, yalnızca dış stil dosyasının tanımladığı kurallara göre işlev görür.
fill="none":

Bu özellik, SVG şekillerinin içinin hangi renk ile doldurulacağını belirler. none değeri, şeklin içinin boş olacağı anlamına gelir, yani iç kısmı şeffaf olur.
xmlns="http://www.w3.org/2000/svg":

Bu, SVG formatının doğru bir şekilde tanımlanabilmesi için gereken XML ad alanı bildirimi. Her SVG öğesinin bu XML ad alanına sahip olması gereklidir, böylece tarayıcılar SVG öğesinin doğru şekilde işleyebilir.

@Output() Dekoratörü:
@Output() dekoratörü, bileşenlerin dış dünyaya (diğer bileşenlere) olay (event) yaymalarını sağlar.
Bu, genellikle bir child (alt) bileşenin parent (üst) bileşene veri göndermek için kullanılır. Yani, bir alt bileşende meydana gelen bir değişiklik, üst bileşene iletilmek için bir olayla yayılabilir.
visibleChange = new EventEmitter<boolean>();:
Bu, visibleChange adında bir EventEmitter nesnesi oluşturur. EventEmitter, Angular'da olayları yaymak için kullanılan bir sınıftır.
<boolean> tipi, bu olayın veri türünü belirtir. Yani, visibleChange olayı bir boolean (doğru/yanlış) değeri taşır. Bu olay, bir boolean değeri taşıyarak tetiklenebilir.
new EventEmitter<boolean>(): Bu, EventEmitter'ı başlatır ve bu olayın boolean türünde veri ile gönderileceğini belirtir. Başka bir deyişle, bu olay, bir true/false değeri ile yayımlanacaktır.
<clipPath id="clip0_1936_18016">
  <rect width="24" height="24" fill="white" transform="translate(16 16)" />
</clipPath>
<clipPath>:
<clipPath> elemanı, bir clip (kesme) yolu tanımlar. İçine yerleştirilen şekil, o şekli kullanarak diğer SVG öğelerinin görünürlüğünü sınırlar.
id="clip0_1936_18016": id özniteliği, bu clipPath öğesine benzersiz bir kimlik verir. Diğer öğeler bu kimlik ile bu clipPath'i kullanabilir. Yani, bu clipPath'in kimliği clip0_1936_18016 olarak tanımlanmıştır.
İçerideki <rect> Elemanı:
html
Kodu kopyala
<rect width="24" height="24" fill="white" transform="translate(16 16)" />
<rect>:

<rect>, SVG içindeki dikdörtgeni tanımlar. Bu örnekte, <rect> elemanı, <clipPath> elemanının içinde yer alır ve bu dikdörtgenin şekli, clipPath ile belirtilen "kesme" işlemini tanımlar.
width="24" ve height="24":

Bu özellikler, dikdörtgenin genişliğini ve yüksekliğini belirtir. Burada, dikdörtgenin boyutları 24x24 birim olarak belirlenmiştir.
fill="white":

fill özniteliği, dikdörtgenin iç rengini belirtir. Burada, dikdörtgenin içi beyaz renkte doldurulmuştur. ClipPath öğesinde bu rengin özellikle önemli bir anlamı vardır, çünkü clipPath'teki şekil beyaz olarak doldurulduğunda, genellikle kesme işlemi için boş bir alan yaratır.
transform="translate(16 16)":

Bu, dikdörtgeni x ve y eksenlerinde 16 birim kaydırarak taşıma işlemi yapar. Bu, dikdörtgenin yerini (konumunu) değiştirir ve (16, 16) koordinatına taşır. Bu, dikdörtgenin başlangıç noktasının 16, 16 olacağı anlamına gelir. Yani dikdörtgenin konumu bu noktaya kaydırılır.
ClipPath'in Kullanımı:
Bu clipPath öğesi, 24x24 birimlik bir dikdörtgen oluşturur ve bu dikdörtgeni (16, 16) koordinatına yerleştirir. Şekil beyaz renk ile doldurulur, bu da clipPath'i uyguladığınızda o alanın görünür olduğu ve gerisinin kesildiği anlamına gelir.

Bu clipPath, başka SVG öğelerine uygulandığında, o öğenin sadece bu dikdörtgenin içine yerleştirilen kısmı görünür hale gelir. Yani, clipPath'i bir nesneye uyguladığınızda, yalnızca (16, 16) konumundaki 24x24 birimlik dikdörtgen alanı gösterilir, geri kalan kısımlar kesilir.

Özet:
<clipPath>: SVG öğelerinin görünürlüğünü sınırlandıran bir "kesme" yolu tanımlar.
<rect>: ClipPath içinde kullanılan şekil, burada 24x24 bir dikdörtgen.
transform="translate(16 16)": Dikdörtgeni 16, 16 konumuna kaydırır.
fill="white": Dikdörtgenin içi beyaz renkle doldurulur ve clipPath işlemi için gerekli alan oluşturulur.
Bu clipPath, başka bir öğeye uygulanarak sadece belirli bir alanın görünür olmasını sağlar.


<input
  type="text"
  [(ngModel)]="value" <!--to data binding-->
  (input)="reset($event)"
  [disabled]="disabled"
  [ngModelOptions]="{ standalone: true }"
  class="border-transparent focus:border-transparent focus:!ring-0 focus:outline-none w-full text-[#6E6E6E] h-[42px] bg-transparent"
  [placeholder]="placeholder"
/>
1. type="text":
type="text", input elemanının türünü belirtir. Burada, kullanıcıdan metin girmesini bekleyen bir metin kutusu (text input) oluşturulur.
2. [(ngModel)]="value":
[(ngModel)]: Bu, Angular'ın "two-way data binding" (iki yönlü veri bağlama) özelliğini kullanır. Yani, input elemanındaki değeri Angular bileşenindeki value değişkenine bağlar ve her iki yönlü veri akışını sağlar.
value: Bu, bileşendeki bir değişkendir ve [(ngModel)] ile bu değerin input kutusunda yansımasını sağlar. Yani, input kutusundaki metin her değiştiğinde, value değişkeni de güncellenir ve tersi de geçerlidir; eğer value güncellenirse, input kutusunda da otomatik olarak görünür.
3. (input)="reset($event)":
(input): Bu, Angular'da bir olay bağlamadır ve input olayı, kullanıcı input kutusuna her şey yazdığında tetiklenir. Yani, inputa her veri girişi yapıldığında bu olay çağrılır.
reset($event): Bu, reset adında bir metodu tetikler ve olayın (event) verisini $event olarak gönderir. Bu metodun içinde, inputtaki her değişiklikle ilgili işlemler yapılabilir. Örneğin, bu fonksiyon, input kutusunun içeriğini sıfırlamak veya başka bir işlem yapmak için kullanılabilir.
4. [disabled]="disabled":
[disabled]: Bu, input kutusunun aktif olup olmamasını kontrol eder. Eğer disabled değişkeni true ise, input kutusu devre dışı (disabled) hale gelir ve kullanıcı yazı yazamaz. Eğer false ise, input kutusu normal şekilde çalışır.
disabled: Bu, bileşendeki bir boolean değişkendir ve input elemanının devre dışı olup olmama durumunu kontrol eder.
5. [ngModelOptions]="{ standalone: true }":
[ngModelOptions]="{ standalone: true }": Bu, ngModel için bir seçenek belirler. standalone: true, ngModel'i form grubu dışında bağımsız bir model olarak kullanmak için kullanılır. Yani, bu input elemanı, Angular formu içinde yer almasa da bağımsız bir model olarak çalışır. Bu, form olmayan, bağımsız inputlar için kullanışlıdır.
6. class="...":
Bu, input elemanına özel CSS sınıflarını tanımlar. Verilen sınıflar şu şekilde açıklanabilir:
border-transparent: Kenarlık rengini saydam (şeffaf) yapar.
focus:border-transparent: Input kutusuna odaklanıldığında kenarlık rengini saydam yapar.
focus:!ring-0: Input kutusuna odaklandığında dış çizgiyi kaldırır.
focus:outline-none: Focus (odak) durumunda dış çizgi (outline) eklemez.
w-full: Input kutusunun genişliğini tam (full) yapar.
text-[#6E6E6E]: Metin rengini belirli bir gri tonuna ayarlar (#6E6E6E).
h-[42px]: Input kutusunun yüksekliğini 42 piksel olarak ayarlar.
bg-transparent: Input kutusunun arka plan rengini saydam yapar.
7. [placeholder]="placeholder":
[placeholder]: Bu özellik, input kutusunun yer tutucu (placeholder) metnini ayarlamak için kullanılır.
placeholder: Bu, bileşendeki bir değişkendir ve input kutusunda yazılı olmayan, kullanıcıya ne tür bir veri girmesi gerektiğini belirten bir metni tutar. Bu metin, input kutusu boşken görünür ve kullanıcı bir şey yazmaya başladığında kaybolur.
<rect x="4" y="4" width="48" height="48" rx="24" fill="#FEE4E2" />
x="4" y="4":

Bu özellikler, dikdörtgenin sol üst köşesinin (x, y) koordinatlarını belirtir.
x="4": Dikdörtgenin yatayda (x ekseninde) 4 birim mesafede başlamasını sağlar.
y="4": Dikdörtgenin dikeyde (y ekseninde) 4 birim mesafede başlamasını sağlar.
width="48" height="48":

width="48": Dikdörtgenin genişliğini 48 birim olarak ayarlar.
height="48": Dikdörtgenin yüksekliğini 48 birim olarak ayarlar.
rx="24":

rx="24": Bu özellik, dikdörtgenin köşelerinin yuvarlatılmasını sağlar. Bu durumda, her bir köşe 24 birim yarıçapında yuvarlatılır, yani dikdörtgenin köşeleri dairesel olur.
fill="#FEE4E2":

fill özniteliği, dikdörtgenin iç rengini belirtir. Burada, #FEE4E2 kodu, çok açık bir pembe rengini ifade eder. Bu renk, dikdörtgenin içini doldurur.
İkinci <rect> Elemanı:
html
Kodu kopyala
<rect
  x="4"
  y="4"
  width="48"
  height="48"
  rx="24"
  stroke="#FEF3F2"
  stroke-width="8"
/>
x="4" y="4":

İlk dikdörtgen gibi, bu dikdörtgen de aynı (4, 4) koordinatından başlar.
width="48" height="48":

Bu dikdörtgenin de boyutları 48x48 birimdir.
rx="24":

Bu dikdörtgen de aynı şekilde, köşeleri 24 birim yarıçapında yuvarlatılmıştır.
stroke="#FEF3F2":

stroke özniteliği, dikdörtgenin dış çizgisinin rengini belirler. Burada, #FEF3F2 kodu, açık bir pembe rengini ifade eder. Yani dikdörtgenin dış kenarları bu renk ile çizilecektir.
stroke-width="8":

stroke-width özniteliği, dikdörtgenin dış kenarının kalınlığını belirler. Burada, kenarın kalınlığı 8 birim olarak ayarlanmıştır.
Özet:
İlk dikdörtgen: 48x48 birim boyutlarında, yuvarlatılmış köşelere sahip bir dikdörtgen olup içi #FEE4E2 (açık pembe) rengiyle doldurulmuş.
İkinci dikdörtgen: Aynı boyutlara ve yuvarlatılmış köşelere sahip olmasına rağmen dış kenarı #FEF3F2 (daha açık pembe) renginde ve dış kenar kalınlığı 8 birimdir.
Bu iki dikdörtgen, genellikle iki katmanlı bir efekt yaratmak için kullanılır. Birincisi arka planda dolgulu bir şekil oluştururken, ikincisi bu şeklin kenarını çizmek için kullanılır. Bu tür tasarımlar, genellikle düğme veya simge tasarımlarında yaygındır.<rect x="4" y="4" width="48" height="48" rx="24" fill="#FEE4E2" />
x="4" y="4":

Bu özellikler, dikdörtgenin sol üst köşesinin (x, y) koordinatlarını belirtir.
x="4": Dikdörtgenin yatayda (x ekseninde) 4 birim mesafede başlamasını sağlar.
y="4": Dikdörtgenin dikeyde (y ekseninde) 4 birim mesafede başlamasını sağlar.
width="48" height="48":

width="48": Dikdörtgenin genişliğini 48 birim olarak ayarlar.
height="48": Dikdörtgenin yüksekliğini 48 birim olarak ayarlar.
rx="24":

rx="24": Bu özellik, dikdörtgenin köşelerinin yuvarlatılmasını sağlar. Bu durumda, her bir köşe 24 birim yarıçapında yuvarlatılır, yani dikdörtgenin köşeleri dairesel olur.
fill="#FEE4E2":

fill özniteliği, dikdörtgenin iç rengini belirtir. Burada, #FEE4E2 kodu, çok açık bir pembe rengini ifade eder. Bu renk, dikdörtgenin içini doldurur.
İkinci <rect> Elemanı:
html
Kodu kopyala
<rect
  x="4"
  y="4"
  width="48"
  height="48"
  rx="24"
  stroke="#FEF3F2"
  stroke-width="8"
/>
x="4" y="4":

İlk dikdörtgen gibi, bu dikdörtgen de aynı (4, 4) koordinatından başlar.
width="48" height="48":

Bu dikdörtgenin de boyutları 48x48 birimdir.
rx="24":

Bu dikdörtgen de aynı şekilde, köşeleri 24 birim yarıçapında yuvarlatılmıştır.
stroke="#FEF3F2":

stroke özniteliği, dikdörtgenin dış çizgisinin rengini belirler. Burada, #FEF3F2 kodu, açık bir pembe rengini ifade eder. Yani dikdörtgenin dış kenarları bu renk ile çizilecektir.
stroke-width="8":

stroke-width özniteliği, dikdörtgenin dış kenarının kalınlığını belirler. Burada, kenarın kalınlığı 8 birim olarak ayarlanmıştır.
Özet:
İlk dikdörtgen: 48x48 birim boyutlarında, yuvarlatılmış köşelere sahip bir dikdörtgen olup içi #FEE4E2 (açık pembe) rengiyle doldurulmuş.
İkinci dikdörtgen: Aynı boyutlara ve yuvarlatılmış köşelere sahip olmasına rağmen dış kenarı #FEF3F2 (daha açık pembe) renginde ve dış kenar kalınlığı 8 birimdir.
Bu iki dikdörtgen, genellikle iki katmanlı bir efekt yaratmak için kullanılır. Birincisi arka planda dolgulu bir şekil oluştururken, ikincisi bu şeklin kenarını çizmek için kullanılır. Bu tür tasarımlar, genellikle düğme veya simge tasarımlarında yaygındır.

1. if (isPlatformBrowser(this._platformId)) { ... }
isPlatformBrowser(this._platformId): Bu kontrol, Angular'ın platform-dependent code (platforma bağlı kod) çalıştırma yöntemidir. Angular, farklı platformlarda çalışabilecek şekilde tasarlanmıştır (örneğin, web tarayıcıları ve sunucu tarafı). Bu kontrol, şu anki ortamın tarayıcıda olup olmadığını kontrol eder.
this._platformId: PLATFORM_ID servisi, Angular'a ait bir servis olup, uygulamanın çalıştığı platformu temsil eder. Bu, tarayıcı, sunucu veya başka bir ortam olabilir.
isPlatformBrowser: Angular'da, bir bileşenin yalnızca tarayıcıda çalışmasını sağlamak için bu fonksiyon kullanılır. Sunucu tarafında çalışırken tarayıcıya özgü kodlar çalıştırmamak için bu kontrol yapılır. Eğer uygulama tarayıcıda çalışıyorsa, kodun içi çalıştırılır.
2. this.subscriptions.add(this.memberService.member.subscribe((member: any) => { ... }))
Bu satır, observable bir veriyi subscribe (abone) eder ve bu veriye dayalı bir işlem yapar.
this.memberService.member: Burada memberService adında bir servis üzerinden gelen member observable'ına abone olunuyor. Bu observable, bir üyelik bilgisi gibi kullanıcıya dair bilgileri sağlayabilir.
subscribe((member: any) => { ... }): memberService.member observable'ına abone olunur ve her veri alındığında (member değiştiğinde) this.user = member ifadesi çalışır. Yani, member verisi geldiğinde, this.user adlı bileşen değişkenine atanır.
3. this.subscriptions.add(this.languageService.sectionData.subscribe((_: string) => { ... }))
this.languageService.sectionData: Bu, languageService adlı bir servisin sectionData observable'ıdır. Bu observable, uygulamanın dil veya içerik verisini sağlayabilir.
subscribe((_: string) => { ... }): Bu observable'a abone olunuyor. Burada _ kullanılarak, gelen parametreyi kullanmadığımızı belirtiyoruz. Yani, sadece verinin geldiği anı bekliyoruz, ancak bu veriyi bir değişkende tutmuyoruz. Gelen veri bir string türünde olacak şekilde belirtilmiş.
this.section = this.languageService.getSection("homepage");: section değişkenine, languageService servisi aracılığıyla alınan "homepage" başlıklı dil verisi atanıyor. Bu, uygulamanın anasayfasına ait verileri temsil edebilir.
this.applicationSection = this.languageService.getSection("newApplication");: applicationSection değişkenine, aynı şekilde "newApplication" başlıklı başka bir dil verisi atanıyor. Bu, uygulamanın yeni başvuru sayfasına ait verileri olabilir.
4. this.subscriptions.add(...)
Her iki abone olma işlemi de this.subscriptions koleksiyonuna ekleniyor. Bu, genellikle aboneliklerin düzgün bir şekilde temizlenebilmesi için yapılır. Angular bileşenlerinde abonelikler, bileşen yok olduğunda ngOnDestroy metodu ile temizlenmelidir. this.subscriptions.add(...) ile yapılan her bir abonelik, bileşenin yok edilmesi sırasında temizlenmesi için takip edilir.
Özet:
isPlatformBrowser(this._platformId): Kodu yalnızca tarayıcıda çalıştırmak için kullanılır.
this.subscriptions.add(...): Bileşenin yaşam döngüsü boyunca yapılan abonelikler takip edilir.
this.memberService.member.subscribe(...): Kullanıcı üyelik bilgileri ile ilgili değişiklikleri takip eder ve this.user değişkenine atar.
this.languageService.sectionData.subscribe(...): Dil veya içerik verilerini takip eder ve this.section ve this.applicationSection değişkenlerini günceller.
ngOnInit(): void {
  this.subscriptions.add(this.languageService.sectionData.subscribe((_: string) => {
    this.section = this.languageService.getSection("homepage");
    this.applicationSection = this.languageService.getSection("newApplication");
  }));
}
1. ngOnInit(): void
Bu metod, Angular bileşenlerinde bileşen başlatıldığında otomatik olarak çağrılır. void geri dönüş tipi, bu metodun herhangi bir değer döndürmediğini belirtir.
ngOnInit genellikle bileşen başlatılmadan önce verilerin yüklenmesi veya başlatılması gibi işlemler için kullanılır.
2. this.subscriptions.add(...)
this.subscriptions bir Subscription nesnesi koleksiyonudur ve birden fazla observable'a abone olunduğunda bunları toplar.
Bu koleksiyon, bileşenin yaşam döngüsü boyunca yapılan aboneliklerin doğru şekilde temizlenmesini sağlamak için kullanılır. add() metodu, yeni bir aboneliği mevcut abonelik listesine ekler.
Bu şekilde, bileşen yok olduğunda (örneğin, kullanıcı sayfayı terk ettiğinde veya bileşen ömrü sona erdiğinde) tüm abonelikler ngOnDestroy metodunda unsubscribe() edilerek temizlenebilir.
3. this.languageService.sectionData.subscribe(...)
this.languageService.sectionData bir observable'dır. Bu observable, muhtemelen uygulamanın dil verisi veya içerik bölümleriyle ilgili bilgileri içeriyor.
subscribe(...) metodu, bu observable'a abone olmanızı sağlar. Abone olduktan sonra, observable her değer güncellendiğinde verilen callback fonksiyonu çalıştırılır.
Burada, (_: string) ifadesi, gelen verinin türünü belirtir (bu durumda bir string). Ancak, bu parametre kullanılamadığı için _ sembolü kullanılmıştır. Yani, gelen değeri burada kullanmıyoruz ama değerin geldiğini takip ediyoruz.
4. this.languageService.getSection("homepage")
this.languageService.getSection("homepage"): languageService servisi içinde tanımlanmış bir metottur. Bu metod, "homepage" başlığını kullanarak belirli bir içerik veya dil verisini alır.
Bu içerik verisi, this.section değişkenine atanır. Bu, bileşenin anasayfası için gerekli verileri temsil edebilir.
5. this.languageService.getSection("newApplication")
this.languageService.getSection("newApplication"): Bu metod da, "newApplication" başlığına sahip dil verisini alır. Bu içerik, uygulamanın yeni başvuru sayfası için kullanılabilir.
Bu veriler, this.applicationSection değişkenine atanır.
Özet:
Bu kod, bileşenin ngOnInit metodunda languageService servisine abone olur. Servisten dil veya içerik verilerini alır.
sectionData observable'ı, dil veya içerik verisi değiştiğinde tetiklenir.
getSection metodu ile "homepage" ve "newApplication" başlıklarına ait içerik verileri alınarak this.section ve this.applicationSection değişkenlerine atanır.
Bu süreç, bileşen başlatıldığında içeriklerin doğru şekilde yüklenmesi için yapılır.
Bu işlem, genellikle dil değişikliği veya içerik güncellemesi gibi dinamik verilerin kullanıldığı uygulamalarda kullanılır.
<input
  [value]="filterText"
  [(ngModel)]="filterText"
  [ngModelOptions]="{ standalone: true }"
  type="text"
  (input)="filterContent()"
  class="border-transparent focus:border-transparent focus:!ring-0 focus:outline-none w-full text-[#1b1b1b] placeholder-[#BBBBBB] text-[14px] md:text-base h-[42px]"
  [placeholder]="section?.searchPlaceholder"
/>
1. [value]="filterText":
Bu, Angular property binding kullanarak input elemanının value özelliğine filterText değişkenini bağlar.
filterText bir model veya bileşen değişkeni olabilir ve input alanının değerini tutar. Ancak burada yalnızca okuma (read-only) yapıldığı için, input elemanının değeri filterText ile güncellenmez, yalnızca görüntülenir.
2. [(ngModel)]="filterText":
Bu, two-way data binding sağlar. Angular'ın ngModel direktifi ile input alanındaki değer, filterText değişkeniyle çift yönlü bağlanır.
Yani, input içindeki değer değiştiğinde filterText değişkeni de güncellenir ve filterText değişkeni değişirse, input alanındaki değer de buna göre güncellenir.
3. [ngModelOptions]="{ standalone: true }":
ngModelOptions özelliği, ngModel direktifinin çalışma şekli üzerinde kontrol sağlar.
standalone: true ayarı, ngModel'i başka bir form elemanına bağlanmadan bağımsız olarak çalıştırmak için kullanılır. Bu, genellikle form elemanları dışında, tek başına çalışan ngModel'i kullanmak için gereklidir.
4. type="text":
type="text": Bu, input elemanının metin türünde olduğunu belirtir. Kullanıcı, burada yalnızca metin girebilir.
5. (input)="filterContent()":
(input): Bu, input elemanına her veri girişi yapıldığında input olayını dinler.
filterContent(): Bu, her input olayında çağrılacak olan bir metottur. Bu metot, genellikle kullanıcının yazdığı metni filtreleme, arama yapma veya veriyi değiştirme gibi işlemleri içerir.
6. class="...":
Bu sınıf, input elemanına özel stil ve görsel ayarları uygular. İlgili sınıflar şunları içerir:
border-transparent: Kenar çizgileri görünmez yapar.
focus:border-transparent: Focus (tıklama) durumunda kenar çizgilerini gizler.
focus:!ring-0: Focus (tıklama) durumunda outline (çevre halkası) yok eder.
focus:outline-none: Focus durumunda outline'ı kaldırır.
w-full: Elemanın genişliğini tam genişlik yapar.
text-[#1b1b1b]: Yazı rengini koyu gri (#1b1b1b) yapar.
placeholder-[#BBBBBB]: Placeholder metninin rengini gri (#BBBBBB) yapar.
text-[14px]: Yazı boyutunu 14px yapar.
md:text-base: Ekran boyutu md (orta boyut) veya daha büyük olduğunda yazı boyutunu base (genel varsayılan boyut) yapar.
h-[42px]: Input alanının yüksekliğini 42px olarak ayarlar.
7. [placeholder]="section?.searchPlaceholder":
[placeholder]: Angular property binding ile placeholder metnini bağlar.
section?.searchPlaceholder: section adlı nesnenin içinde searchPlaceholder özelliğine bakar. Eğer section nesnesi tanımlıysa, searchPlaceholder değeri input'un placeholder'ı olarak gösterilir. ?. operatörü, null veya undefined değerleri kontrol eder, yani section mevcut değilse hata almazsınız.
<img
  *ngIf="coverImageSrc2"
  [ngSrc]="
    environment.apiUrl +
    '/file/get?mimeType=image/jpeg&fileName=' +
    coverImageSrc2
  "
  priority
  class="w-full h-full object-cover object-center absolute"
  [class]="coverClass2"
  width="1444"
  height="678"
  alt="e-Visa"
/>
1. *ngIf="coverImageSrc2":
*ngIf: Bu, Angular'ın yapısal bir direktifidir ve belirli bir koşula bağlı olarak öğeyi DOM'a ekler veya çıkarır.
coverImageSrc2: coverImageSrc2 adlı bileşen değişkeni burada kullanılır. Eğer coverImageSrc2 değeri truthy (doğru değeri) ise, yani tanımlı ve geçerli bir değere sahipse, bu <img> elemanı DOM'a eklenir ve gösterilir. Eğer coverImageSrc2 değeri false, null veya undefined gibi bir falsy değere sahipse, bu <img> elemanı gösterilmez.
2. [ngSrc]="...":
[ngSrc]: Angular'ın özel ngSrc binding özelliği, src özniteliği için gelişmiş bir bağlama sağlar. Bu, Angular'ın src ile ilgili veri yükleme stratejisini optimize etmek için kullanılır. Normalde, src değeri doğrudan bağlanırken, ngSrc ile bağlantı yapıldığında, Angular, src değerinin doğru şekilde yerleşmesini sağlamak için daha kontrollü bir yöntem sunar.
Bağlama ifadesi:
typescript
Kodu kopyala
environment.apiUrl + '/file/get?mimeType=image/jpeg&fileName=' + coverImageSrc2
Bu, environment.apiUrl ile başlayan bir URL oluşturur. Bu URL, bir API'ye istek göndermek için kullanılacak ve API'den coverImageSrc2 adlı dosya ismini alarak bir JPEG görseli almayı amaçlar. coverImageSrc2 burada dosya adını temsil eder.
environment.apiUrl: Genellikle bir yapılandırma dosyasından (örneğin, environment.ts dosyasından) alınan API'nin temel URL'si.
/file/get?mimeType=image/jpeg&fileName=: Görüntüyü almak için kullanılacak API yoludur.
coverImageSrc2: Görüntü dosyasının adı. Bu değer dinamik olarak bileşende belirlenir.
3. priority:
Bu, HTML5'in yeni bir özelliği olup, görüntünün öncelikli yüklenmesini belirtir. priority etiketi, sayfa yüklendiğinde bu görselin hızlıca yüklenmesi gerektiğini belirtir. Bu özellik, genellikle sayfa ilk açıldığında kritik olan görseller için kullanılır.
4. class="w-full h-full object-cover object-center absolute":
w-full: Görselin genişliğini tam (full) genişlik yapar.
h-full: Görselin yüksekliğini tam (full) yükseklik yapar.
object-cover: Görselin, container (kapsayıcı) elemanının boyutlarına uyacak şekilde kesilmeden tam olarak yerleştirilmesini sağlar. Görüntü oranını koruyarak kapsayıcıyı doldurur.
object-center: Görselin merkezde konumlanmasını sağlar.
absolute: Görselin konumunun mutlak (absolute) olması gerektiğini belirtir. Yani, üstteki ve soldaki referans noktalarına göre konumlanır.
5. [class]="coverClass2":
[class]: Bu, Angular'ın class binding özelliğidir. coverClass2 değişkeninin değerine göre bir sınıf (CSS sınıfı) dinamik olarak eklenir veya çıkarılır.
coverClass2: Bu, bileşende tanımlı bir değişken olup, input değerine göre farklı CSS sınıflarını elemanın sınıf listesine ekler.
6. width="1444" ve height="678":
Bu, görselin genişlik ve yükseklik özelliklerini belirler. Görselin boyutları 1444x678 piksel olarak sabitlenmiş.
7. alt="e-Visa":
alt: Görselin alternatif metnini belirtir. Eğer görsel yüklenemezse veya görseli göremeyen bir kullanıcı varsa, bu metin görsel yerine gösterilir. Burada "e-Visa" yazısı kullanılmış.

// Language service.ts
import { isPlatformServer } from "@angular/common"; // Angular platformunu kontrol etmek için kullanılan fonksiyon
import { Inject, Injectable, PLATFORM_ID } from "@angular/core"; // Dependency Injection için kullanılan sınıflar
import { BehaviorSubject } from "rxjs"; // Reactive programming için kullanılacak veri akışları
import { StorageService } from "./storage.service"; // LocalStorage ile ilgili servis

@Injectable({
  providedIn: "root", // Bu servisi Angular'ın root modülünde sağlayacağımızı belirtir
})
export class LanguageService {
  // Şu anda kullanılan dilin kodu (örn. "en" için İngilizce)
  public currentLanguageCode: BehaviorSubject<string> =
    new BehaviorSubject<string>("en");

  // Şu anda kullanılan dilin adı (örn. "English" için İngilizce)
  public currentLanguageName: BehaviorSubject<string> =
    new BehaviorSubject<string>("English");

  constructor(
    private storageService: StorageService, // LocalStorage'ı yöneten servis
    @Inject(PLATFORM_ID) private _platformId: Object // Platform kimliğini almak için kullanılır (tarayıcı mı, sunucu mu?)
  ) {
    // LocalStorage'dan dil ayarlarını alıyoruz ve sayfa dilini buna göre ayarlıyoruz
    const localStorageData = storageService.getLocalStorage(); // LocalStorage'dan veri al
    if (localStorageData && localStorageData.localization) {
      this.currentLanguageCode.next(
        JSON.parse(localStorageData.localization)?.code ?? "en"
      ); // Dil kodunu ayarla
      this.currentLanguageName.next(
        JSON.parse(localStorageData.localization)?.name ?? "English"
      ); // Dil adını ayarla
      document
        .querySelector("html")
        ?.setAttribute(
          "dir",
          JSON.parse(localStorageData.localization)?.rtl ? "rtl" : "ltr"
        ); // Yazı yönünü ayarla (sağdan sola ya da soldan sağa)
    }
  }

  // Başlık verisini tutmak için kullanılan BehaviorSubject
  public headerText: BehaviorSubject<string> = new BehaviorSubject<string>("");

  // Dil çevirisi için kullanılacak veri
  public sectionData: BehaviorSubject<any> = new BehaviorSubject<any[]>([]);

  // Tercüme edilen veri
  public translateData: any[] = [];
  
  // Dil bölüm verisi
  sections: any[] = [];

  // Dil değiştirme fonksiyonu
  changeLanguage(languageCode: string, languageName: string, rtl: boolean) {
    rtl = languageCode.toLowerCase() == "ar"; // Eğer dil Arapça ise, yazı yönünü sağdan sola ayarla
    this.storageService.setLocalStorage(
      "localization", // LocalStorage'a dil ayarlarını kaydet
      JSON.stringify({
        code: languageCode, // Dil kodu
        name: languageName, // Dil adı
        rtl: rtl, // Yazı yönü (Arapça için sağdan sola)
      })
    );
    this.currentLanguageCode.next(languageCode); // Dil kodunu güncelle
    this.currentLanguageName.next(languageName); // Dil adını güncelle
    document.querySelector("html")?.setAttribute("dir", rtl ? "rtl" : "ltr"); // Sayfa dilini ayarla
    if (this.sections == null) return;
    this.setSectionData(this.sections); // Sayfa içeriğini güncelle
  }

  // Belirli bir belge tipini almak için kullanılan fonksiyon
  getAdditionalDocumentTypes() {
    const guid = "13571426-0489-453d-bcc6-624783830cbd"; // Belirli bir belge tipi için GUID
    return this.translateData.filter(
      (x) =>
        x.guidKey == guid && // Belirli GUID'ye göre filtrele
        this.currentLanguageCode.value.toLowerCase() == x.language // Aktif dil ile eşleşen çeviriyi al
    );
  }

  // Boş değerleri İngilizce değerlerle doldurur
  fillEmptyValuesWithEnglish(target: any, source: any) {
    for (let i = 0; i < Object.keys(target).length; i++) {
      const obj = target[Object.keys(target)[i]]; // Hedef objedeki eleman
      const srcObj = source[Object.keys(target)[i]]; // Kaynak objedeki eleman
      if (typeof obj === "object" && typeof srcObj === "object") {
        this.fillEmptyValuesWithEnglish(obj, srcObj); // Rekürsif olarak alt objelere bak
      } else {
        if (obj == "" || obj == null) {
          target[Object.keys(target)[i]] = source[Object.keys(target)[i]]; // Boş veya null olan değerleri kaynak değerle doldur
        }
      }
    }
  }

  // Dil verilerini ayarlamak için kullanılan fonksiyon
  setSectionData(sections: any[]) {
    this.sections = sections; // Bölüm verilerini sakla
    for (
      let i = 0;
      i <
      this.sections.filter((x) => JSON.parse(x.content)?.lang != "en").length;
      i++
    ) {
      const section = this.sections.filter(
        (x) => JSON.parse(x.content)?.lang != "en"
      )[i]; // Dil "en" (İngilizce) olmayan bölümleri al
      const sectionEn = this.sections.find(
        (x) =>
          JSON.parse(x.content)?.lang == "en" &&
          x.sectionHandle == section.sectionHandle
      ); // Aynı bölümün İngilizce versiyonunu bul
      const targetJson = JSON.parse(section.content); // Hedef bölüm verisini JSON'a çevir
      if (sectionEn?.content) {
        const sourceJson = JSON.parse(sectionEn.content); // İngilizce bölüm verisini JSON'a çevir
        this.fillEmptyValuesWithEnglish(targetJson?.data, sourceJson?.data); // Eksik verileri İngilizce ile doldur
        this.sections.filter((x) => JSON.parse(x.content)?.lang != "en")[i].content = JSON.stringify(targetJson); // Veriyi güncelle
      }
    }
    this.sectionData.next(this.sections); // Güncellenmiş veriyi yayınla
  }

  // Tercüme verisini ayarlamak için kullanılan fonksiyon
  setTranslateData(sections: any[]) {
    this.translateData = sections; // Tercüme verisini sakla
  }

  // Belirli bir bölüm verisini almak için kullanılan fonksiyon
  getSection(name: string) {
    const section = this.sectionData?.value?.find(
      (x: any) =>
        x.sectionHandle == name && // Bölüm adıyla eşleşen veriyi bul
        JSON.parse(x.content ?? "[]")?.lang == this.currentLanguageCode.value.toLowerCase() // Dil kodu ile eşleşen veriyi bul
    );
    return section ? JSON.parse(section.content)?.data : null; // Bölüm verisini döndür
  }

  // Birden fazla bölümü almak için kullanılan fonksiyon
  getSections(name: string) {
    const sections = this.sectionData?.value.filter(
      (x: any) =>
        x.sectionHandle == name && // Bölüm adıyla eşleşen verileri filtrele
        JSON.parse(x.content ?? "[]")?.lang == this.currentLanguageCode.value.toLowerCase() // Dil kodu ile eşleşen verileri filtrele
    );
    return sections ?? []; // Bölümleri döndür
  }

  // Form elemanları için dil çevirisini almak
  getInput(key: string) {
    if (isPlatformServer(this._platformId)) // Eğer sunucuda çalışıyorsak, boş değer döndür
      return { label: "", placeholder: "" };
    const sectionName = "form_elements"; // Form elemanları bölümü
    let section = this.sectionData?.value.find(
      (x: any) =>
        x.sectionHandle == sectionName &&
        JSON.parse(x.content ?? "[]")?.lang == this.currentLanguageCode.value.toLowerCase()
    ); // Form elemanları bölümünü bul
    if (!section)
      section = this.sectionData?.value.find(
        (x: any) =>
          x.sectionHandle == sectionName &&
          JSON.parse(x.content ?? "[]")?.lang == "en"
      ); // Eğer mevcut dilde bulunmazsa İngilizceyi bul

    if (!section) {
      return {
        label: "", // Eğer bölüm bulunamazsa boş değer döndür
        placeholder: "",
      };
    }
    return JSON.parse(section.content)?.data[key]; // Çevirisini döndür
  }

  // GUID ile çeviri almak
  getTranslation(guid: string) {
    const translation = this.translateData.find(
      (x) =>
        x.language == this.currentLanguageCode.value.toLowerCase() && // Aktif dil ile eşleşen çeviriyi bul
        x.guidKey == guid // Belirtilen GUID ile eşleşen çeviriyi bul
    );
    if (translation) return translation.value; // Çeviriyi döndür

    const original = this.translateData.find(
      (x) => x.language == "en" && x.guidKey == guid // Eğer dilde bulunmazsa, İngilizceyi bul
    );
    if (original) return original.value; // İngilizce çeviriyi döndür

    return ""; // Çeviri bulunamazsa boş döndür
  }

  // API hata mesajlarını almak
  getError(name: string) {
    const messages: any[] = this.getSection("api_messages"); // API mesajlarını al
    const messagesDict = [
      { key: "EMAIL_VERIFY", value: "emailVerify" },
      { key: "USER_NOT_FOUND", value: "userNotFound" },
      { key: "USERNAME_OR_PASSWORD_ERROR", value: "usernameOrPasswordError" },
      { key: "OLD_PASSWORD_INCORRECT", value: "oldPasswordIncorrect" },
      { key: "APPLICATION_GROUP_NOT_FOUND", value: "applicationGroupNotFound" },
      {
        key: "CAPTCHA_ERROR_INCORRECT_CODE",
        value: "captchaErrorIncorrectCode",
      },
      { key: "PASSWORD_POLICY_VIOLATION", value: "passwordControl" },
      { key: "ONGOING_PAYMENT_CHARGE", value: "ongoingPayment" },
      { key: "required", value: "required" },
      { key: "invalid", value: "invalid" },
    ];
    const key = messagesDict.find((x) => x.key == name)?.value ?? ""; // Hata mesajını eşleştir
    if (messages) {
      if (Object.keys(messages).indexOf(key) != -1)
        return Object.values(messages)[Object.keys(messages).indexOf(key)];
      if (Object.keys(messages).indexOf(name) != -1)
        return Object.values(messages)[Object.keys(messages).indexOf(name)];
    }
    return name; // Eğer mesaj bulunmazsa, ismi döndür
  }

  // Belirli bir condition'ı (koşulu) almak
  getCondition(id: string) {
    const messages: any[] = this.getSection("conditions")?.conditions;
    if (messages?.find((x) => x.conditionId == id.toString()))
      return messages?.find((x) => x.conditionId == id.toString()).translation;
    return null; // Eğer koşul bulunmazsa, null döndür
  }

  // Koşul çevirisini almak
  getConditionTranslation(condition: any) {
    const translation = condition?.translateDtos?.find(
      (x: any) => x.language == this.currentLanguageCode.value.toLowerCase() // Aktif dildeki çeviriyi al
    );
    if (translation) return translation.value;

    const original = condition?.translateDtos?.find(
      (x: any) => x.language == "en" // İngilizce çeviriyi al
    );
    if (original) return original.value;
  }

  // Milliyet çevirisini almak
  public getNationality(nationality: string) {
    const messages: any[] = this.getSection("nationalities")?.nationalities;
    if (messages?.find((x) => x.key == nationality))
      return messages?.find((x) => x.key == nationality).translation;

    return nationality; // Eğer milliyet bulunamazsa, kendi değerini döndür
  }

  // Vize tipi çevirisini almak
  public getVisaType(visaType: string) {
    const messages: any[] = this.getSection("visaTypes")?.visaTypes;
    if (messages?.find((x) => x.key == visaType))
      return messages?.find((x) => x.key == visaType).translation;

    return visaType; // Eğer vize tipi bulunamazsa, kendi değerini döndür
  }

  // Uçuş bilgisi çevirisini almak
  public getFlightInformation(flightInformation: string) {
    const messages: any[] =
      this.getSection("flight_information")?.flightInformations;
    if (messages?.find((x) => x.key == flightInformation))
      return messages?.find((x) => x.key == flightInformation).translation;

    return flightInformation; // Eğer uçuş bilgisi bulunamazsa, kendi değerini döndür
  }

  // Seyahat belgesi çevirisini almak
  public getTravelDocument(travelDocument: string) {
    const messages: any[] =
      this.getSection("travel_documents")?.travelDocuments;
    if (messages?.find((x) => x.key == travelDocument))
      return messages?.find((x) => x.key == travelDocument).translation;

    return travelDocument; // Eğer seyahat belgesi bulunamazsa, kendi değerini döndür
  }

  // Ek belge çevirisini almak
  public getAdditionalDocuments(additionalDoc: string) {
    const messages: any[] = this.getSection(
      "additional_documents"
    )?.additionalDocuments;
    if (messages?.find((x) => x.key == additionalDoc))
      return messages?.find((x) => x.key == additionalDoc).translation;

    return additionalDoc; // Eğer ek belge bulunamazsa, kendi değerini döndür
  }

  // Cinsiyet çevirisini almak
  public getGender(gender: string) {
    const messages: any[] = this.getSection("genders")?.genders;
    if (messages?.find((x) => x.key == gender))
      return messages?.find((x) => x.key == gender).translation;

    return gender; // Eğer cinsiyet bulunamazsa, kendi değerini döndür
  }

  // Vize durumu çevirisini almak
  getVisaStatus(status: string) {
    const messages: any[] =
      this.getSection("profile")?.applications?.visaStatus;
    if (Object.keys(messages ?? {})?.indexOf(status) != -1)
      return Object.values(messages)[Object.keys(messages).indexOf(status)];
    return status; // Eğer vize durumu bulunamazsa, kendi değerini döndür
  }
}
///////////
Login component ts
import { isPlatformBrowser } from "@angular/common"; // Tarayıcıda çalışıp çalışmadığını kontrol etmek için kullanılan fonksiyon
import { HttpClient } from "@angular/common/http"; // HTTP isteği yapmak için kullanılan servis
import {
  AfterViewInit,
  ChangeDetectorRef,
  Component,
  EventEmitter,
  Inject,
  OnDestroy,
  OnInit,
  PLATFORM_ID,
} from "@angular/core"; // Angular'ın temel modüllerinden ilgili sınıflar
import { FormBuilder, FormGroup } from "@angular/forms"; // Form oluşturmak için kullanılan araçlar
import { Title } from "@angular/platform-browser"; // Sayfa başlığını değiştirmek için kullanılan servis
import { ActivatedRoute, Router } from "@angular/router"; // Yönlendirme ve parametreleri almak için
import { Subscription } from "rxjs"; // Observable aboneliklerini yönetmek için
import { environment } from "../../../environment/environment"; // Çevresel değişkenler
import { SpinnerService } from "../../components/spinner/spinner.service"; // Yükleniyor göstergesi (spinner) servisi
import { LanguageService } from "../../shared/language.service"; // Dil servisi
import { MemberService } from "../../shared/member.service"; // Üye hizmeti

// Error tipini tanımlıyoruz
interface Error {
  email: string; // E-posta hatası
  password: string; // Şifre hatası
}

@Component({
  selector: "app-login", // Bileşenin HTML tag'ı
  templateUrl: "./login.component.html", // Bu bileşenin HTML template'i
})
export class LoginComponent implements OnInit, AfterViewInit, OnDestroy {
  constructor(
    private spinnerService: SpinnerService, // Yükleniyor göstergesi için servis
    private route: ActivatedRoute, // Aktif route üzerinden parametreler almak için
    private router: Router, // Sayfa yönlendirmeleri için
    private fb: FormBuilder, // Form oluşturmak için
    private memberService: MemberService, // Üye servisi
    private languageService: LanguageService, // Dil servisi
    private titleService: Title, // Sayfa başlığı için
    private httpClient: HttpClient, // HTTP istekleri için
    private cdr: ChangeDetectorRef, // Angular değişiklik tespitini tetiklemek için
    @Inject(PLATFORM_ID) private _platformId: Object // Platform kimliğini almak için (tarayıcı mı yoksa sunucu mu?)
  ) { }

  private subscriptions = new Subscription(); // Aktif aboneliklerin yönetileceği nesne

  section: any; // Sayfa verisi (login bölümüne ait veriler)
  loginErrorModal = false; // Giriş hatası modal'ını kontrol etmek için
  showMissingInformation = false; // Eksik bilgi uyarısını göstermek için
  missingErrors: any[] = []; // Eksik bilgilerle ilgili hata mesajları
  passwordHidden = true; // Şifreyi gizlemek/göstermek için

  environment = environment; // Çevresel değişkenler
  returnUrl: string | undefined; // Başka bir sayfaya yönlendirme için kullanılan URL
  loginForm: FormGroup | undefined; // Form verilerini tutacak form grubu
  showVerifiedModal = false; // Hesap doğrulama modal'ı için

  // Varsayılan kimlik bilgileri
  defaultAuth: any = {
    email: "",
    password: "",
  };

  errors: Error = {
    password: "", // Şifre hatası mesajı
    email: "", // E-posta hatası mesajı
  };

  error: string | null = null; // Genel hata mesajı

  // ngAfterViewInit - Bileşen görünümünü oluşturduktan sonra çalışacak olan fonksiyon
  ngAfterViewInit(): void { }

  // ngOnDestroy - Bileşen yok olduğunda çalışacak olan fonksiyon
  ngOnDestroy(): void {
    this.subscriptions.unsubscribe(); // Abonelikleri temizliyoruz
  }

  // ngOnInit - Bileşen başlatıldığında çalışacak olan fonksiyon
  ngOnInit(): void {
    // Eğer platform tarayıcıysa (Sunucu tarafı render edilmez)
    if (isPlatformBrowser(this._platformId)) {
      const token = this.route.snapshot.paramMap.get("token"); // URL parametrelerinden token alıyoruz
      if (token) {
        // Eğer token varsa, üyeyi doğrulamak için API çağrısı yapıyoruz
        this.httpClient
          .get(`${environment.apiUrl}/member/verify/${token}`)
          .subscribe((user: any) => {
            this.memberService.setLocalStorage(user); // Üye verilerini localStorage'a kaydediyoruz
            this.showVerifiedModal = true; // Doğrulama modal'ını gösteriyoruz
          });
      } else {
        // Eğer token yoksa, üye verilerini kontrol ediyoruz
        this.subscriptions.add(this.memberService.member.subscribe((member) => {
          if (member) this.router.navigate(["/profile"]); // Eğer üye varsa, profile sayfasına yönlendiriyoruz
        }));
      }

      // Dil verisini almak için 'languageService' üzerinden abone oluyoruz
      this.subscriptions.add(this.languageService.sectionData.subscribe(() => {
        this.section = this.languageService.getSection("login"); // "login" bölümünü alıyoruz
        if (!this.section) return; // Eğer bölüm bulunmazsa, işlem yapmıyoruz
        this.titleService.setTitle(this.section.og.title); // Sayfa başlığını güncelliyoruz
        this.spinnerService.display(false); // Yükleniyor göstergesini kapatıyoruz
      }));

      // Yönlendirilmesi gereken URL'yi alıyoruz
      this.returnUrl =
        this.route.snapshot.queryParams["returnUrl".toString()] || "/"; // Eğer yönlendirme URL'si varsa onu al, yoksa ana sayfaya git
    }
  }

  // Kullanıcıdan gelen hataları kontrol eden fonksiyon
  hasError() {
    return Object.values(this.errors).find((x: string) => x != ""); // Eğer herhangi bir hata varsa true döner
  }

  // Dil verisini almak için kullanılan fonksiyon
  getInput(key: string) {
    return this.languageService.getInput(key); // 'key' ile eşleşen çeviriyi döndürür
  }

  // Giriş işlemini yapan fonksiyon
  submit() {
    this.missingErrors = []; // Hata listelerini sıfırlıyoruz
    if (this.defaultAuth.email == "") {
      // Eğer e-posta boşsa, hata mesajı ekliyoruz
      this.missingErrors.push(this.getInput("email")?.label);
      this.errors.email = "required"; // E-posta hatası
    }
    if (this.defaultAuth.password == "") {
      // Eğer şifre boşsa, hata mesajı ekliyoruz
      this.missingErrors.push(this.getInput("password")?.label);
      this.errors.password = "required"; // Şifre hatası
    }
    if (this.hasError()) {
      // Eğer hata varsa, eksik bilgi uyarısını gösteriyoruz
      this.showMissingInformation = true;
      return;
    }

    // Giriş işlemi için spinner'ı gösteriyoruz
    this.spinnerService.display(true);
    this.memberService
      .login(this.defaultAuth.email, this.defaultAuth.password) // Giriş işlemi için API çağrısı yapıyoruz
      .subscribe({
        next: (v) => {
          // Başarılı girişte, üye verilerini localStorage'a kaydedip, profile sayfasına yönlendiriyoruz
          this.memberService.setLocalStorage(v);
          this.router.navigate(["/profile"]);
          //this.spinnerService.display(false); // Yükleniyor göstergesini kapatıyoruz
        },
        error: (e) => {
          // Hata oluşursa, hata mesajını alıp modal'ı gösteriyoruz
          this.error = this.languageService.getError(e.error.message);
          this.loginErrorModal = true;
          this.spinnerService.display(false); // Yükleniyor göstergesini kapatıyoruz
          this.cdr.detectChanges(); // Değişiklik tespiti
        },
        complete: () => { }, // Tamamlandığında herhangi bir işlem yapmıyoruz
      });
  }
}
////////////
contact component ts 

import { isPlatformBrowser } from "@angular/common";
import { HttpClient } from "@angular/common/http";
import {
  ChangeDetectorRef,
  Component,
  Inject,
  OnDestroy,
  OnInit,
  PLATFORM_ID,
} from "@angular/core";
import { DomSanitizer, Title } from "@angular/platform-browser";
import { AsYouType } from "libphonenumber-js";
import { Subscription } from "rxjs";
import { environment } from "../../../environment/environment";
import { SpinnerService } from "../../components/spinner/spinner.service";
import { LanguageService } from "../../shared/language.service";
import { MemberService } from "../../shared/member.service";
// form verileri Error isimli interfaceden geliyor
interface Error {
  firstName: string;
  lastName: string;
  email: string;
  phoneNumber: string;
  conditions: string;
  message: string;
  captcha: string;
}
@Component({
  selector: "app-contact",
  templateUrl: "./contact.component.html",
})
export class ContactComponent implements OnInit, OnDestroy {
  constructor(
    private spinnerService: SpinnerService,
    private memberService: MemberService,
    private httpClient: HttpClient,
    private sanitizer: DomSanitizer,
    private languageService: LanguageService,
    private titleService: Title,
    @Inject(PLATFORM_ID) private _platformId: Object,
    private cdr: ChangeDetectorRef
  ) { }
  private subscriptions = new Subscription();

  numbersOnlyValidator(event: any) {
    const pattern = /^[0-9\-]*$/; // regular expression
    if (!pattern.test(event.target.value)) {
      //input alanına girilen değer pattern ile uyumlumu 
      event.target.value = event.target.value.replace(/[^0-9\-]/g, "");
    }
  }

  refreshCaptcha() {
    //tarayıcda calsııyorsa true sunucuda çalısıyorsa false doner
    if (isPlatformBrowser(this._platformId)) {
      this.httpClient
      // blog binry veri veya görselmiş
        .get<Blob>(environment.apiUrl + "/contact/getcaptcha", {
          responseType: "blob" as "json", //http yanıtı sonucu bir blog binay veri captcha için
          observe: "response", // ceavı bana headders ve body olarak al
        })
        .subscribe((resp) => {
          this.captchaId = resp.headers.get("X-Captcha-Id")?.toString() ?? "";
          let objectURL = URL.createObjectURL(resp.body!); // blob verisini bir geçici URL'ye dönüştürür. Bu URL, görselin tarayıcıda gösterilmesini sağlar.
          this.captchaData = this.sanitizer.bypassSecurityTrustUrl(objectURL); //url yi güvenli bir url olarak işaretler
        });
    }
  }
  errors: Error = {
    firstName: "",
    lastName: "",
    email: "",
    phoneNumber: "",
    conditions: "",
    message: "",
    captcha: "",
  };
  translatedNationalities: any = [];
  nationalities$: any;

  errorPopup = false;
  successPopup = false;

  conditions = false;
  conditionModal = false;
  section: any;
  user: any = null;
  environment = environment;
  captchaId = "";
  captchaData: any;
  captchaCode = "";
  member: any;
  name = "";
  surname = "";
  email = "";
  phone = "";
  message = "";
  nation: any;
  getErrorMessage(key: string) {
    return this.languageService.getError(key);
  }
  ngOnInit(): void {
    // Eğer platform tarayıcıysa, kodu çalıştır (Sunucu tarafı render sırasında bu kısım çalışmaz)
    if (isPlatformBrowser(this._platformId)) {
      
      // 'languageService' üzerinden dil verilerini alıyoruz. 'sectionData' bir Observable.
      this.subscriptions.add(this.languageService.sectionData.subscribe(() => {
        
        // "contact" sekmesini almak için dil servisinden veri çekiyoruz
        this.section = this.languageService.getSection("contact");
  
        // Eğer section bulunmazsa, fonksiyonu erken sonlandırıyoruz
        if (!this.section) return;
  
        // section verisi varsa, başlık bilgisi set ediliyor
        if (this.section) this.titleService.setTitle(this.section.og.title);
  
        // Eğer 'nationalities$' (uluslararası veriler) varsa, verileri işle
        if (this.nationalities$) {
          this.translatedNationalities = []; // Yeni bir boş dizi başlatıyoruz
          
          // 'nationalities$' dizisinde döngüye girip her bir ulus için çeviri ekliyoruz
          for (let nation of this.nationalities$) {
            this.translatedNationalities.push({
              guid: nation.guid, // Her ulusun benzersiz kimliği
              name: this.languageService.getTranslation(nation.guid), // Çevrilen ulus adı
              phoneCode: nation.phoneCode, // Telefon kodu
            });
          }
        }
  
        // Ulusları isme göre sıralıyoruz
        this.translatedNationalities = this.translatedNationalities.sort(
          (x: any, y: any) => ("" + x.name).localeCompare(y.name)
        );
  
        // 'memberService' üzerinden üye verisini alıyoruz ve spinner'ı durduruyoruz
        this.memberService.member.subscribe((member) => {
          this.user = member; // Üye verisi
          this.member = member; // Üye verisi
          this.spinnerService.display(false); // Yükleniyor spinner'ını gizle
        });
      }));
  
      // CAPTCHA verisini almak için bir HTTP isteği gönderiyoruz
      this.httpClient
        .get<Blob>(environment.apiUrl + "/contact/getcaptcha", {
          responseType: "blob" as "json", // Yanıt tipi olarak 'blob' (ikili veri) belirliyoruz
          observe: "response", // Tam yanıt objesini almak istiyoruz
        })
        .subscribe((resp) => {
          // CAPTCHA ID'sini başlıklardan alıyoruz
          this.captchaId = resp.headers.get("X-Captcha-Id")?.toString() ?? "";
  
          // CAPTCHA'nın verilerini URL'e dönüştürüp güvenli hale getiriyoruz
          let objectURL = URL.createObjectURL(resp.body!);
          this.captchaData = this.sanitizer.bypassSecurityTrustUrl(objectURL);
        });
  
      // Ulusal kimlik listesine dair bir HTTP isteği yapıyoruz
      this.httpClient
        .get(
          `${environment.apiUrl
          }/nationality/list?isTurkiye=true&timestamp=${new Date().getTime()}`
        )
        .subscribe((data: any) => {
          // 'nationalities$' verisini alıyoruz
          this.nationalities$ = data.data;
          
          // Eğer veriler geldiyse, her bir ulus için çeviri işlemi yapıyoruz
          if (this.nationalities$) {
            for (let nation of this.nationalities$) {
              this.translatedNationalities.push({
                guid: nation.guid, // Her ulusun benzersiz kimliği
                name: this.languageService.getTranslation(nation.guid), // Çevrilen ulus adı
                phoneCode: nation.phoneCode, // Telefon kodu
              });
            }
  
            // Çevrilen ulusları isme göre sıralıyoruz
            this.translatedNationalities = this.translatedNationalities.sort(
              (x: any, y: any) => ("" + x.name).localeCompare(y.name)
            );
          }
        });
    }
  }
  
  ngOnDestroy(): void {
    // Bileşen yok olurken tüm abonelikleri temizliyoruz
    this.subscriptions.unsubscribe();
  }
  
  getInput(key: string) {
    // Ana dil servisi üzerinden verilen 'key' parametresinin çevirisini alıyoruz
    return this.languageService.getInput(key);
  }
  
  checkConditions() {
    // Koşulların geçerliliğini kontrol ediyoruz
    this.conditions = !this.conditions; // Koşulların geçerliliğini tersine çeviriyoruz
    if (this.conditions) this.conditionModal = true; // Eğer geçerli ise, modal'ı açıyoruz
    this.errors.conditions = ""; // Hata mesajını sıfırlıyoruz
  }
  
  hasError() {
    // Eğer hatalar varsa, herhangi bir hata mesajını döndürüyoruz
    return Object.values(this.errors).find((x: string) => x != "");
  }
  
  
  validateEmail() {
    const validRegex =
      /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/;

      // verilen ifade ile eşleşmediiyse ve null ise invalid hatası göndr
    if (!this.email.match(validRegex) && this.errors.email == "") {
      this.errors.email = "invalid";
    }
  }
// .input(event.target.value) ifadesi, event.target.value (kullanıcının form alanına yazdığı değer) ile telefon numarasını alır ve bu değeri, AsYouType sınıfının input fonksiyonu ile işleyerek, doğru biçimlendirilmiş telefon numarasını döndürür.
//Bu sonuç, this.phone değişkenine atanır. Böylece, biçimlendirilmiş telefon numarası sınıfın bir özelliği olarak saklanır.
  asYouType(event: any) {
    this.phone = new AsYouType().input(event.target.value);
    this.cdr.detectChanges();
  }

  send() {
    // veriler boşsa onları required olarak uyartıyor
    if (this.name == "") this.errors.firstName = "required";
    if (this.surname == "") this.errors.lastName = "required";
    if (this.phone == "") this.errors.phoneNumber = "required";
    if (this.email == "") this.errors.email = "required";
    if (!this.conditions) this.errors.conditions = "required";
    if (this.message == "") this.errors.message = "required";
    if (this.captchaCode == "") this.errors.captcha = "required";
    this.validateEmail();

    if (this.hasError()) return;

    this.spinnerService.display(true);// loading simgesi göstermek için
    this.httpClient
      .post(environment.apiUrl + "/contact/send", {
        // gönderilecek parametreler
        captchaGuid: this.captchaId,
        captchaCode: this.captchaCode,
        email: this.email,
        message: this.message,
        name: this.name,
        phone: "string",
        surname: this.surname,
      })
      .subscribe({
        // v obsersavble tarafından dondurulen veriyi temsil eder
        next: (v: any) => {
          // değerleri sıfırlıyor
          this.name = "";
          //degerleri sıfırlıyor
          this.surname = "";
          //degerleri sıfırlıyor
          this.email = "";
          //degerleri sıfırlıyor
          this.phone = "";
          //degerleri sıfırlıyor
          this.conditions = false;
          this.message = "";
          //degerleri sıfırlıyor
          this.spinnerService.display(false); // yükleme simgesini gizle
          if (v.success) this.successPopup = true; // veri başarılı bir şekilde geliyorsa başarı popupu
          else this.errorPopup = true;  //başrısız ise eroor popupu aç
          this.refreshCaptcha();   // captchayı yenile
        },
        //  hata varsa apiden gelen veride hata varsa veya istek yapılamadıysa
        error: (e) => {
          // hata mesajı captca error incorrerct code ise
          if (e.error?.message == "CAPTCHA_ERROR_INCORRECT_CODE") {
            this.errors.captcha = "invalid"; // gerçersiz ata
          } else this.errorPopup = true; // başka b,r hata varsa
          this.refreshCaptcha();
          this.spinnerService.display(false); // loading kısmını kapat
        },
        complete: () => { }, // işlem bittiğinde birşey yapma 
      });
  }
}

//////////////
faq component ts 
import { Component, Inject, OnDestroy, OnInit, PLATFORM_ID } from "@angular/core"; // Angular core modüllerini ve 'PLATFORM_ID' platform bilgisi için import ediyoruz
import { Title } from "@angular/platform-browser"; // Sayfa başlığını değiştirebilmek için 'Title' servisini import ediyoruz
import { SpinnerService } from "../../components/spinner/spinner.service"; // Yükleniyor göstergesi (spinner) için 'SpinnerService' servisini import ediyoruz
import { LanguageService } from "../../shared/language.service"; // Dil hizmeti için 'LanguageService' servisini import ediyoruz
import { Subscription } from "rxjs"; // RxJS'ten Subscription, observable abonelikleri için kullanılıyor

@Component({
  selector: "app-faq", // Bileşenin HTML tag'ı
  templateUrl: "./faq.component.html", // Bu bileşenin HTML template'i
})
export class FaqComponent implements OnInit, OnDestroy {
  // Bileşen içindeki gerekli servisler constructor aracılığıyla inject ediliyor
  constructor(
    private languageService: LanguageService, // Dil servisi
    private titleService: Title, // Başlık servisi
    private spinnerService: SpinnerService, // Spinner servisi (yükleniyor göstergesi)
  ) { }

  private subscriptions = new Subscription(); // Bileşenin aktif aboneliklerini tutan bir Subscription nesnesi

  section: any; // FAQ (Sıkça Sorulan Sorular) bölümü verisini tutacak değişken
  filterText = ""; // Arama için kullanılacak metin
  selectedIndex = 0; // Seçili olan soruyu belirten indeks
  filteredContent: any; // Filtrelenmiş içeriği tutacak değişken

  // ngOnInit - Bileşen başlatıldığında çalışacak kod
  ngOnInit() {
    this.spinnerService.display(true); // Sayfa yükleniyor göstergesini aktif ediyoruz
    this.subscriptions.add(this.languageService.sectionData.subscribe(() => {
      // 'languageService.sectionData' observable'ına abone oluyoruz ve veriler değiştiğinde işlem yapıyoruz
      this.section = this.languageService.getSection("faq"); // 'faq' bölümü verisini alıyoruz

      if (!this.section) return; // Eğer 'faq' bölümü yoksa, işlemden çıkıyoruz

      this.filterContent(); // İçeriği filtreliyoruz
      this.titleService.setTitle(this.section.og.title); // Sayfa başlığını güncelliyoruz
      this.spinnerService.display(false); // Yükleniyor göstergesini kapatıyoruz
    }));
  }

  // ngOnDestroy - Bileşen yok olduğunda çalışacak kod
  ngOnDestroy(): void {
    this.subscriptions.unsubscribe(); // Bileşen yok olurken, tüm aktif abonelikleri sonlandırıyoruz
  }

  // setSelectedIndex - Seçilen soruyu belirlemek için
  setSelectedIndex(index: number) {
    // Eğer aynı soru seçildiyse, açmayı/kapatmayı sağlıyoruz
    this.selectedIndex = this.selectedIndex == index ? -1 : index;
  }

  // filterContent - Arama metnine göre içeriği filtreleyen fonksiyon
  filterContent() {
    var items: any = []; // Filtrelenmiş içerikleri tutacak geçici bir dizi oluşturuyoruz

    for (let i = 0; i < this.section?.content?.length; i++) { 
      // 'faq' bölümündeki tüm içerikleri döngü ile kontrol ediyoruz
      const item = this.section?.content[i]; // Her bir öğeyi alıyoruz

      // Arama metni (filterText) için bir RegExp (düzenli ifade) oluşturuyoruz
      const regex = new RegExp(
        `(${this.filterText.replace(/e/, "e[-]?")})`, // 'e' harfini 'e' ya da 'e-' şeklinde esnek yapıyoruz
        "gi" // 'g' global (tüm metin içinde) ve 'i' büyük/küçük harfe duyarsız
      );

      let found = false; // Filtreli metin bulunup bulunmadığını takip eden değişken
      // Yanıt metnini HTML etiketlerini koruyarak filtreliyoruz
      const highlightedAnswer = item?.answer.replace(
        /(<[^>]*>|[^<]*)/g, // HTML etiketleri dışındaki metni bul
        (match: any) => {
          if (match.startsWith("<")) return match; // Eğer HTML etiketi ise, olduğu gibi bırakıyoruz
          const newText = match.replace(regex, (m: any) => {
            found = true; // Eğer arama metni bulunduysa, 'found' değişkenini true yapıyoruz
            return `<span style="background-color: yellow;">${m}</span>`; // Bulunan metni vurguluyoruz
          });
          return newText;
        }
      );

      // Soru metnini de benzer şekilde filtreliyoruz
      const highlightedQuestion = item?.question?.replace(
        regex,
        (match: any) => {
          return `<span class="highlight">${match}</span>`; // Soru metnindeki eşleşmeleri vurguluyoruz
        }
      );

      // Eğer arama metni boş değilse veya filtreli içerik varsa, öğeyi filtrelenmiş içerik listesine ekliyoruz
      if (
        this.filterText == "" ||
        this.filterText == null ||
        item?.question
          ?.replaceAll("-", "")
          .toLowerCase()
          .includes(this.filterText.toLowerCase()) || // Soru metninde arama metni varsa
        found // Yanıt kısmında arama metni bulunduysa
      ) {
        items.push({
          question: highlightedQuestion, // Vurgulanan soru metni
          answer: highlightedAnswer, // Vurgulanan yanıt metni
        });
      }
    }

    // Filtrelenmiş içeriği güncelliyoruz
    this.filteredContent = items;
  }
}
////////////////////////////

register component ts 
import { isPlatformBrowser } from "@angular/common"; // Tarayıcı ortamında çalışıp çalışmadığını kontrol eder
import { HttpClient } from "@angular/common/http"; // HTTP istekleri yapabilmek için kullanılan servis
import {
  ChangeDetectorRef,
  Component,
  EventEmitter,
  Inject,
  OnDestroy,
  OnInit,
  PLATFORM_ID
} from "@angular/core"; // Angular bileşenleri ve yaşam döngüsü metodları için gerekli importlar
import { DomSanitizer, Title } from "@angular/platform-browser"; // HTML güvenlik işlemleri ve sayfa başlığını ayarlamak için kullanılan servisler
import { Router } from "@angular/router"; // Angular yönlendirme işlemleri için kullanılan servis
import { Subscription } from "rxjs"; // Observable aboneliklerini yönetmek için
import { environment } from "../../../environment/environment"; // Uygulama çevresel ayarları (API URL, vb.)
import { SpinnerService } from "../../components/spinner/spinner.service"; // Yükleniyor göstergesi (spinner) servis
import { LanguageService } from "../../shared/language.service"; // Dil servisi
import { MemberService } from "../../shared/member.service"; // Üye işlemleri için servis

// Formda kullanılacak hataları tanımlayan interface
interface Error {
  firstName: string;
  lastName: string;
  birthday: string;
  nationality: string;
  gender: string;
  email: string;
  password: string;
  captcha: string;
}

@Component({
  selector: "app-register", // Bileşenin HTML tag'ı
  templateUrl: "./register.component.html", // Bu bileşenin HTML şablonu
})
export class RegisterComponent implements OnInit, OnDestroy {
  constructor(
    private cdr: ChangeDetectorRef, // Değişiklik tespiti için
    private router: Router, // Yönlendirme işlemleri için
    private httpClient: HttpClient, // HTTP istekleri için
    private sanitizer: DomSanitizer, // Güvenlik önlemi almak için
    private memberService: MemberService, // Üye işlemleri için servis
    public languageService: LanguageService, // Dil servisi
    private titleService: Title, // Sayfa başlığını değiştirmek için
    @Inject(PLATFORM_ID) private _platformId: Object, // Hangi platformda çalıştığımızı belirlemek için
    private spinnerService: SpinnerService // Yükleniyor göstergesi (spinner) için servis
  ) { }

  private subscriptions = new Subscription(); // Aboneliklerin yönetilmesi için

  environment = environment; // Çevresel değişkenler

  // CAPTCHA verisini yenileyen metod
  refreshCaptcha() {
    this.member.captchaCode = ""; // CAPTCHA kodunu sıfırlıyoruz

    // Yeni CAPTCHA verisi almak için API isteği gönderiyoruz
    this.httpClient
      .get<Blob>(environment.apiUrl + "/captcha/getcaptcha", {
        responseType: "blob" as "json",
        observe: "response",
      })
      .subscribe((resp) => {
        this.captchaId = resp.headers.get("X-Captcha-Id")?.toString() ?? ""; // CAPTCHA ID'sini alıyoruz
        let objectURL = URL.createObjectURL(resp.body!); // CAPTCHA resmini oluşturuyoruz
        this.captchaData = this.sanitizer.bypassSecurityTrustUrl(objectURL); // Güvenli URL oluşturuyoruz
        this.cdr.detectChanges(); // Değişiklik tespiti yapıyoruz
      });
  }

  loginErrorModal = false; // Giriş hatası modal'ı durumu
  minBirthday = new Date(1900, 1, 1); // Doğum tarihi için minimum tarih
  today = new Date(); // Bugünün tarihi
  section: any; // Sayfaya ait dil verisi
  nationalities: any; // Ülkeler listesi
  translatedNationalities: any = []; // Çevrilmiş ülkeler
  country = ""; // Ülke bilgisi
  missingErrors: any = []; // Eksik bilgi hataları
  showMissingInformation = false; // Eksik bilgi uyarısını göster
  member: any = { // Üye bilgileri
    captchaCode: "",
    nationalityGuid: null,
    name: "",
    secondName: "",
    lastName: "",
    eMail: "",
    phone: "",
    address: "",
    birthDay: "",
    motherName: "",
    fatherName: "",
    password: "",
    isEMailVerification: false,
    status: true,
    gender: null,
  };
  
  // Hataları tanımlıyoruz
  errors: Error = {
    firstName: "",
    lastName: "",
    birthday: "",
    nationality: "",
    gender: "",
    email: "",
    password: "",
    captcha: "",
  };

  userExistsModal = false; // Kullanıcı zaten var hatası modal'ı
  registeredModal = false; // Kayıt başarılı modal'ı
  error: null | string = null; // Genel hata mesajı
  reloadEvent: EventEmitter<boolean> = new EventEmitter(); // Sayfa yenileme olayı
  captchaId = ""; // CAPTCHA ID'si
  captchaData: any; // CAPTCHA verisi
  submitted = false; // Form gönderilip gönderilmediğini kontrol eder

  // ngOnInit - Bileşen başlatıldığında çalışacak fonksiyon
  ngOnInit(): void {
    if (isPlatformBrowser(this._platformId)) { // Eğer platform tarayıcı ise çalışacak kod
      // Dil verisini almak ve başlığı ayarlamak için abone oluyoruz
      this.subscriptions.add(this.languageService.sectionData.subscribe(() => {
        this.section = this.languageService.getSection("register");
        if (!this.section) return;
        this.titleService.setTitle(this.section.og.title); // Sayfa başlığını ayarlıyoruz
        this.spinnerService.display(false); // Spinner'ı kapatıyoruz

        this.translatedNationalities = []; // Çevrilmiş ulkeler listesini sıfırlıyoruz
        if (this.nationalities) {
          // Ülkeler listesini çeviriyoruz
          for (let nation of this.nationalities) {
            this.translatedNationalities.push({
              guid: nation.guid,
              name: this.languageService.getTranslation(nation.guid),
            });
          }
        }
      }));

      // Ülkeler listesini alıyoruz
      this.httpClient
        .get(
          `${environment.apiUrl
          }/nationality/list?timestamp=${new Date().getTime()}`
        )
        .subscribe((data: any) => {
          this.nationalities = data.data; // Ülkeler verisini alıyoruz
          this.translatedNationalities = []; // Çevrilmiş ülkeler listesini sıfırlıyoruz
          if (this.nationalities) {
            // Çevrilmiş ülkeler listesini dolduruyoruz
            for (let nation of this.nationalities) {
              this.translatedNationalities.push({
                guid: nation.guid,
                name: this.languageService.getTranslation(nation.guid),
              });
            }
          }
        });

      // Kullanıcı bilgilerini kontrol ediyoruz (zaten giriş yapmışsa, anasayfaya yönlendiriyoruz)
      this.subscriptions.add(this.memberService.member.subscribe((member) => {
        if (member) this.router.navigate(["/"]);
      }));

      // CAPTCHA resmini alıyoruz
      this.httpClient
        .get<Blob>(environment.apiUrl + "/captcha/getcaptcha", {
          responseType: "blob" as "json",
          observe: "response",
        })
        .subscribe((resp) => {
          this.captchaId = resp.headers.get("X-Captcha-Id")?.toString() ?? ""; // CAPTCHA ID'sini alıyoruz
          let objectURL = URL.createObjectURL(resp.body!); // CAPTCHA görselini oluşturuyoruz
          this.captchaData = this.sanitizer.bypassSecurityTrustUrl(objectURL); // Güvenli URL oluşturuyoruz
        });
    }
  }

  // ngOnDestroy - Bileşen yok olduğunda çalışacak fonksiyon
  ngOnDestroy(): void {
    this.subscriptions.unsubscribe(); // Tüm abonelikleri iptal ediyoruz
  }

  // Formdaki dil verilerini almak için kullanılan metod
  getInput(key: string) {
    return this.languageService.getInput(key);
  }

  // Cinsiyet çevirisi için kullanılan metod
  getGender(key: string) {
    return this.languageService.getGender(key);
  }

  // Şifre doğrulama metodunu yazıyoruz
  validatePassword() {
    const symbolRegex = /[.!#$%&'*+/=?^_`{|}~-]/;
    const lowerCaseRegex = /[a-z]/;
    const upperCaseRegex = /[A-Z]/;
    const digitRegex = /[0-9]/;
    
    // Şifrenin belirli kurallara uymasını kontrol ediyoruz
    if (
      !this.member.password.match(symbolRegex) ||
      !this.member.password.match(lowerCaseRegex) ||
      !this.member.password.match(upperCaseRegex) ||
      !this.member.password.match(digitRegex) ||
      this.member.password.length < 8
    ) {
      if (this.errors.password == "") {
        this.errors.password = "invalid"; // Geçersiz şifre hatası
        this.missingErrors.push(this.getInput("password")?.label); // Eksik bilgi hatasına şifreyi ekliyoruz
      }
    }
  }

  // E-posta doğrulama metodunu yazıyoruz
  validateEmail() {
    const validRegex = /\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/;
    if (!this.member.eMail.match(validRegex) && this.errors.email == "") {
      this.errors.email = "invalid"; // Geçersiz e-posta hatası
      this.missingErrors.push(this.getInput("email")?.label); // Eksik bilgi hatasına e-posta bilgisini ekliyoruz
    }
  }

  // Form hatalarını kontrol eden metod
  hasError() {
    // Gerekli alanlar eksikse hata mesajlarını ekliyoruz
    if (this.member.name == "") {
      this.errors.firstName = "required";
      this.missingErrors.push(this.getInput("firstName")?.label); // Eksik isim hatası
    }
    if (this.member.birthDay == "") {
      this.missingErrors.push(this.getInput("birthday")?.label); // Eksik doğum tarihi hatası
      this.errors.birthday = "required";
    }
    if (
      this.member.nationalityGuid == "" ||
      this.member.nationalityGuid == null
    ) {
      this.errors.nationality = "required"; // Eksik ulus hatası
      this.missingErrors.push(this.getInput("nationality")?.label);
    }
    if (this.member.gender == "" || this.member.gender == null) {
      this.missingErrors.push(this.getInput("gender")?.label); // Eksik cinsiyet hatası
      this.errors.gender = "required";
    }
    if (this.member.eMail == "") {
      this.missingErrors.push(this.getInput("email")?.label); // Eksik e-posta hatası
      this.errors.email = "required";
    } else this.validateEmail(); // E-posta doğrulama
    if (this.member.password == "") {
      this.missingErrors.push(this.getInput("password")?.label); // Eksik şifre hatası
      this.errors.password = "required";
    } else this.validatePassword(); // Şifre doğrulama
    if (this.member.captchaCode == "") {
      this.missingErrors.push(this.getInput("captcha")?.label); // Eksik CAPTCHA hatası
      this.errors.captcha = "required";
    }
    return Object.values(this.errors).find((x: string) => x != "");
  }

  // Hata mesajlarını almak için kullanılan metod
  getErrorMessage(key: string) {
    return this.languageService.getError(key);
  }

  // Formu göndermek için kullanılan metod
  nextStep() {
    this.missingErrors = []; // Eksik bilgi hatalarını sıfırlıyoruz
    if (this.hasError()) {
      this.showMissingInformation = true; // Hata varsa uyarıyı gösteriyoruz
      return;
    }
    this.member.surname = this.member.lastName; // Soyadı bilgisini eşliyoruz
    this.member.captchaGuid = this.captchaId; // CAPTCHA ID'sini ekliyoruz
    this.spinnerService.display(true); // Spinner'ı açıyoruz
    // API isteği ile üyeyi ekliyoruz
    this.httpClient
      .post(
        environment.apiUrl + "/member/add",
        {
          ...this.member,
          lang: this.languageService.currentLanguageCode.value, // Dil bilgisini ekliyoruz
        },
        {
          responseType: "text", // Yanıt tipini metin olarak alıyoruz
        }
      )
      .subscribe({
        next: (v) => {
          this.refreshCaptcha(); // CAPTCHA'yı yeniliyoruz
          this.captchaData = ""; // CAPTCHA verisini sıfırlıyoruz
          this.cdr.detectChanges(); // Değişiklikleri algılıyoruz
          this.httpClient
            .get<Blob>(environment.apiUrl + "/captcha/getcaptcha", {
              responseType: "blob" as "json",
              observe: "response",
            })
            .subscribe((resp) => {
              this.member.captchaCode = ""; // CAPTCHA kodunu sıfırlıyoruz
              this.captchaId =
                resp.headers.get("X-Captcha-Id")?.toString() ?? ""; // CAPTCHA ID'sini alıyoruz
              let objectURL = URL.createObjectURL(resp.body!); // CAPTCHA görselini oluşturuyoruz
              this.captchaData =
                this.sanitizer.bypassSecurityTrustUrl(objectURL); // Güvenli URL oluşturuyoruz
              this.cdr.detectChanges(); // Değişiklikleri algılıyoruz
            });

          this.registeredModal = true; // Kayıt başarılı mesajını gösteriyoruz
          this.spinnerService.display(false); // Spinner'ı kapatıyoruz

          this.cdr.detectChanges(); // Değişiklikleri algılıyoruz
        },
        error: (e) => {
          this.refreshCaptcha(); // CAPTCHA'yı yeniliyoruz
          this.member.captchaCode = ""; // CAPTCHA kodunu sıfırlıyoruz
          this.captchaData = ""; // CAPTCHA görselini sıfırlıyoruz
          this.httpClient
            .get<Blob>(environment.apiUrl + "/captcha/getcaptcha", {
              responseType: "blob" as "json",
              observe: "response",
            })
            .subscribe((resp) => {
              this.captchaId =
                resp.headers.get("X-Captcha-Id")?.toString() ?? ""; // CAPTCHA ID'sini alıyoruz
              let objectURL = URL.createObjectURL(resp.body!); // CAPTCHA görselini oluşturuyoruz
              this.captchaData =
                this.sanitizer.bypassSecurityTrustUrl(objectURL); // Güvenli URL oluşturuyoruz
            });

          const errorMessage = this.languageService.getError(
            JSON.parse(e.error)?.message
          ); // Hata mesajını alıyoruz
          this.spinnerService.display(false); // Spinner'ı kapatıyoruz
          if (errorMessage == "ENTER_VALID_EMAIL") {
            this.errors.email = "invalid"; // Geçersiz e-posta hatası
            this.missingErrors.push(this.getInput("email")?.label); // Eksik e-posta hatasını ekliyoruz
            this.spinnerService.display(false); // Spinner'ı kapatıyoruz
            return;
          } else if (errorMessage == "RECORD_ALREADY_ADDED") {
            this.userExistsModal = true; // Kullanıcı zaten var hatasını gösteriyoruz
            return;
          }
          this.error = errorMessage; // Hata mesajını saklıyoruz
          this.showMissingInformation = true; // Eksik bilgi hatasını gösteriyoruz
        },
        complete: () => { }, //işlem bittiğinde ....
      });
  }
}

